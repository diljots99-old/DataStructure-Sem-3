{\rtf1\ansi\deff0\deftab720{\fonttbl{\f0\fmodern Courier New;}}
{\colortbl\red0\green0\blue0;\red255\green255\blue255;\red200\green200\blue200;\red0\green0\blue0;\red160\green160\blue160;\red190\green190\blue230;\red128\green128\blue255;\red0\green128\blue128;\red128\green0\blue0;\red240\green0\blue240;\red240\green200\blue240;\red0\green0\blue160;\red135\green135\blue200;\red0\green160\blue0;\red154\green200\blue154;\red190\green0\blue190;\red190\green137\blue190;\red0\green0\blue255;\red190\green190\blue255;\red224\green160\blue0;\red224\green206\blue159;\red132\green160\blue132;\red255\green0\blue0;\red255\green200\blue200;\red128\green255\blue255;\red64\green64\blue128;\red133\green133\blue172;}
{\info{\comment Generated by the Code::Blocks RTF Exporter plugin}
{\title Untitled}}

\deflang1033\pard\plain\f0\fs16   1  \cb3\cf4 /*
\par \cb1\cf0\ul0\i0\b0   2  \cb3\cf4 *Convert infix to postfix using Stack
\par \cb1\cf0\ul0\i0\b0   3  \cb3\cf4 */
\par \cb1\cf0\ul0\i0\b0   4  \cb3\cf13 #include  "stdio.h "
\par \cb1\cf0\ul0\i0\b0   5  \cb3\cf13 #include "stdlib.h " \cb3\cf4 /* for exit() */
\par \cb1\cf0\ul0\i0\b0   6  \cb3\cf13 #include " ctype.h " \cb3\cf4 /* for isdigit(char ) */
\par \cb1\cf0\ul0\i0\b0   7  \cb3\cf13 #include "string.h "
\par \cb1\cf0\ul0\i0\b0   8  
\par \cb1\cf0\ul0\i0\b0   9  \cb3\cf13 #define SIZE 100
\par \cb1\cf0\ul0\i0\b0  10  
\par \cb1\cf0\ul0\i0\b0  11  \cb3\cf11\b char \b0\cb1\cf0 stack\cb3\cf22 [\cb1\cf0 SIZE\cb3\cf22 ];
\par \cb1\cf0\ul0\i0\b0  12  \cb3\cf11\b int \b0\cb1\cf0 top \cb3\cf22 = -\cb3\cf9 1\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  13  
\par \cb1\cf0\ul0\i0\b0  14  \cb3\cf4 /* define push operation */
\par \cb1\cf0\ul0\i0\b0  15  
\par \cb1\cf0\ul0\i0\b0  16  \cb3\cf11\b void \b0\cb1\cf0 push\cb3\cf22 (\cb3\cf11\b char \b0\cb1\cf0 item\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  17  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  18      \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 top \cb3\cf22 >= \cb1\cf0 SIZE \cb3\cf22 - \cb3\cf9 1\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  19      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  20          \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "\\nStack Overflow."\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  21      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  22      \cb3\cf11\b else
\par \cb1\cf0\ul0\i0\b0  23      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  24          \cb1\cf0 top \cb3\cf22 = \cb1\cf0 top \cb3\cf22 + \cb3\cf9 1\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  25          \cb1\cf0 stack\cb3\cf22 [\cb1\cf0 top\cb3\cf22 ] = \cb1\cf0 item\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  26      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  27  \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  28  
\par \cb1\cf0\ul0\i0\b0  29  \cb3\cf4 /* define pop operation */
\par \cb1\cf0\ul0\i0\b0  30  \cb3\cf11\b char \b0\cb1\cf0 pop\cb3\cf22 ()
\par \cb1\cf0\ul0\i0\b0  31  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  32      \cb3\cf11\b char \b0\cb1\cf0 item\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  33  
\par \cb1\cf0\ul0\i0\b0  34      \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 top \cb3\cf22 < \cb3\cf9 0\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  35      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  36          \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "stack under flow: invalid infix expression"\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  37          \cb1\cf0 getchar\cb3\cf22 ();
\par \cb1\cf0\ul0\i0\b0  38          \cb1\cf0 exit\cb3\cf22 (\cb3\cf9 1\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  39      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  40      \cb3\cf11\b else
\par \cb1\cf0\ul0\i0\b0  41      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  42          \cb1\cf0 item \cb3\cf22 = \cb1\cf0 stack\cb3\cf22 [\cb1\cf0 top\cb3\cf22 ];
\par \cb1\cf0\ul0\i0\b0  43          \cb1\cf0 top \cb3\cf22 = \cb1\cf0 top \cb3\cf22 - \cb3\cf9 1\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  44          \cb3\cf11\b return \b0\cb3\cf22 (\cb1\cf0 item\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  45      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  46  \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  47  
\par \cb1\cf0\ul0\i0\b0  48  \cb3\cf11\b int \b0\cb1\cf0 is_operator\cb3\cf22 (\cb3\cf11\b char \b0\cb1\cf0 symbol\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  49  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  50      \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '^' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '*' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '/' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '+' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '-'\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  51      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  52          \cb3\cf11\b return \b0\cb3\cf9 1\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  53      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  54      \cb3\cf11\b else
\par \cb1\cf0\ul0\i0\b0  55      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  56          \cb3\cf11\b return \b0\cb3\cf9 0\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  57      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  58  \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  59  
\par \cb1\cf0\ul0\i0\b0  60  \cb3\cf11\b int \b0\cb1\cf0 precedence\cb3\cf22 (\cb3\cf11\b char \b0\cb1\cf0 symbol\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  61  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  62      \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '^'\cb3\cf22 ) \cb3\cf4 /* exponent operator, highest precedence*/
\par \cb1\cf0\ul0\i0\b0  63      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  64          \cb3\cf11\b return \b0\cb3\cf22 (\cb3\cf9 3\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  65      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  66      \cb3\cf11\b else if \b0\cb3\cf22 (\cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '*' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '/'\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  67      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  68          \cb3\cf11\b return \b0\cb3\cf22 (\cb3\cf9 2\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  69      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  70      \cb3\cf11\b else if \b0\cb3\cf22 (\cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '+' \cb3\cf22 || \cb1\cf0 symbol \cb3\cf22 == \cb3\cf19 '-'\cb3\cf22 ) \cb3\cf4 /* lowest precedence */
\par \cb1\cf0\ul0\i0\b0  71      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  72          \cb3\cf11\b return \b0\cb3\cf22 (\cb3\cf9 1\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  73      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  74      \cb3\cf11\b else
\par \cb1\cf0\ul0\i0\b0  75      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  76          \cb3\cf11\b return \b0\cb3\cf22 (\cb3\cf9 0\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  77      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  78  \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  79  
\par \cb1\cf0\ul0\i0\b0  80  \cb3\cf11\b void \b0\cb1\cf0 InfixToPostfix\cb3\cf22 (\cb3\cf11\b char \b0\cb1\cf0 infix_exp\cb3\cf22 [], \cb3\cf11\b char \b0\cb1\cf0 postfix_exp\cb3\cf22 [])
\par \cb1\cf0\ul0\i0\b0  81  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  82      \cb3\cf11\b int \b0\cb1\cf0 i\cb3\cf22 , \cb1\cf0 j\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  83      \cb3\cf11\b char \b0\cb1\cf0 item\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  84      \cb3\cf11\b char \b0\cb1\cf0 x\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  85  
\par \cb1\cf0\ul0\i0\b0  86      \cb1\cf0 push\cb3\cf22 (\cb3\cf19 '('\cb3\cf22 ); \cb3\cf4 /* push '(' onto stack */
\par \cb1\cf0\ul0\i0\b0  87      \cb1\cf0 strcat\cb3\cf22 (\cb1\cf0 infix_exp\cb3\cf22 , \cb3\cf17 ")"\cb3\cf22 ); \cb3\cf4 /* add ')' to infix expression */
\par \cb1\cf0\ul0\i0\b0  88      \cb1\cf0 i \cb3\cf22 = \cb3\cf9 0\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  89      \cb1\cf0 j \cb3\cf22 = \cb3\cf9 0\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0  90      \cb1\cf0 item \cb3\cf22 = \cb1\cf0 infix_exp\cb3\cf22 [\cb1\cf0 i\cb3\cf22 ]; \cb3\cf4 /* initialize before loop*/
\par \cb1\cf0\ul0\i0\b0  91  
\par \cb1\cf0\ul0\i0\b0  92      \cb3\cf11\b while \b0\cb3\cf22 (\cb1\cf0 item \cb3\cf22 != \cb3\cf19 '\\0'\cb3\cf22 ) \cb3\cf5 //run loop till end of infix expression * /
\par \cb1\cf0\ul0\i0\b0  93      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  94          \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 item \cb3\cf22 == \cb3\cf19 '('\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0  95          \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0  96              \cb1\cf0 push\cb3\cf22 (\cb1\cf0 item\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0  97          \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0  98          \cb3\cf11\b else if \b0\cb3\cf22 (\cb1\cf0 isdigit\cb3\cf22 (\cb1\cf0 item\cb3\cf22 ) || \cb1\cf0 isalpha\cb3\cf22 (\cb1\cf0 item\cb3\cf22 ))
\par \cb1\cf0\ul0\i0\b0  99          \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 100              \cb1\cf0 postfix_exp\cb3\cf22 [\cb1\cf0 j\cb3\cf22 ] = \cb1\cf0 item\cb3\cf22 ; \cb3\cf4 /*add operand symbol to postfix expr */
\par \cb1\cf0\ul0\i0\b0 101              \cb1\cf0 j\cb3\cf22 ++;
\par \cb1\cf0\ul0\i0\b0 102          \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 103          \cb3\cf11\b else if \b0\cb3\cf22 (\cb1\cf0 is_operator\cb3\cf22 (\cb1\cf0 item\cb3\cf22 ) == \cb3\cf9 1\cb3\cf22 ) \cb3\cf4 /* means symbol is operator */
\par \cb1\cf0\ul0\i0\b0 104          \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 105              \cb1\cf0 x \cb3\cf22 = \cb1\cf0 pop\cb3\cf22 ();
\par \cb1\cf0\ul0\i0\b0 106              \cb3\cf11\b while \b0\cb3\cf22 (\cb1\cf0 is_operator\cb3\cf22 (\cb1\cf0 x\cb3\cf22 ) == \cb3\cf9 1 \cb3\cf22 && \cb1\cf0 precedence\cb3\cf22 (\cb1\cf0 x\cb3\cf22 ) >= \cb1\cf0 precedence\cb3\cf22 (\cb1\cf0 item\cb3\cf22 ))
\par \cb1\cf0\ul0\i0\b0 107              \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 108                  \cb1\cf0 postfix_exp\cb3\cf22 [\cb1\cf0 j\cb3\cf22 ] = \cb1\cf0 x\cb3\cf22 ; \cb3\cf4 /* so pop all higher precendence operator and */
\par \cb1\cf0\ul0\i0\b0 109                  \cb1\cf0 j\cb3\cf22 ++;
\par \cb1\cf0\ul0\i0\b0 110                  \cb1\cf0 x \cb3\cf22 = \cb1\cf0 pop\cb3\cf22 (); \cb3\cf4 /* add them to postfix expresion */
\par \cb1\cf0\ul0\i0\b0 111              \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 112              \cb1\cf0 push\cb3\cf22 (\cb1\cf0 x\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 113              \cb1\cf0 push\cb3\cf22 (\cb1\cf0 item\cb3\cf22 ); \cb3\cf4 /* push current oprerator symbol onto stack */
\par \cb1\cf0\ul0\i0\b0 114          \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 115          \cb3\cf11\b else if \b0\cb3\cf22 (\cb1\cf0 item \cb3\cf22 == \cb3\cf19 ')'\cb3\cf22 ) \cb3\cf4 /* if current symbol is ')' then */
\par \cb1\cf0\ul0\i0\b0 116          \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 117              \cb1\cf0 x \cb3\cf22 = \cb1\cf0 pop\cb3\cf22 (); \cb3\cf4 /* pop and keep popping until */
\par \cb1\cf0\ul0\i0\b0 118              \cb3\cf11\b while \b0\cb3\cf22 (\cb1\cf0 x \cb3\cf22 != \cb3\cf19 '('\cb3\cf22 ) \cb3\cf4 /* '(' encounterd */
\par \cb1\cf0\ul0\i0\b0 119              \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 120                  \cb1\cf0 postfix_exp\cb3\cf22 [\cb1\cf0 j\cb3\cf22 ] = \cb1\cf0 x\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0 121                  \cb1\cf0 j\cb3\cf22 ++;
\par \cb1\cf0\ul0\i0\b0 122                  \cb1\cf0 x \cb3\cf22 = \cb1\cf0 pop\cb3\cf22 ();
\par \cb1\cf0\ul0\i0\b0 123              \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 124          \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 125          \cb3\cf11\b else
\par \cb1\cf0\ul0\i0\b0 126          \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 127              \cb3\cf4 /* if current symbol is neither operand not '(' nor ')' and nor operator */
\par \cb1\cf0\ul0\i0\b0 128              \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "\\nInvalid infix Expression.\\n"\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 129              \cb1\cf0 getchar\cb3\cf22 ();
\par \cb1\cf0\ul0\i0\b0 130              \cb1\cf0 exit\cb3\cf22 (\cb3\cf9 1\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 131          \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 132          \cb1\cf0 i\cb3\cf22 ++;
\par \cb1\cf0\ul0\i0\b0 133          \cb1\cf0 item \cb3\cf22 = \cb1\cf0 infix_exp\cb3\cf22 [\cb1\cf0 i\cb3\cf22 ]; \cb3\cf4 /* go to next symbol of infix expression */
\par \cb1\cf0\ul0\i0\b0 134      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 135  
\par \cb1\cf0\ul0\i0\b0 136      \cb3\cf11\b if \b0\cb3\cf22 (\cb1\cf0 top \cb3\cf22 > \cb3\cf9 0\cb3\cf22 )
\par \cb1\cf0\ul0\i0\b0 137      \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 138          \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "\\nInvalid infix Expression.\\n"\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 139          \cb1\cf0 getchar\cb3\cf22 ();
\par \cb1\cf0\ul0\i0\b0 140          \cb1\cf0 exit\cb3\cf22 (\cb3\cf9 1\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 141      \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 142      \cb1\cf0 postfix_exp\cb3\cf22 [\cb1\cf0 j\cb3\cf22 ] = \cb3\cf19 '\\0'\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0 143  
\par \cb1\cf0\ul0\i0\b0 144  \cb3\cf22 \}
\par \cb1\cf0\ul0\i0\b0 145  
\par \cb1\cf0\ul0\i0\b0 146  \cb3\cf4 /* main function begins */
\par \cb1\cf0\ul0\i0\b0 147  \cb3\cf11\b int \b0\cb1\cf0 main\cb3\cf22 ()
\par \cb1\cf0\ul0\i0\b0 148  \cb3\cf22 \{
\par \cb1\cf0\ul0\i0\b0 149      \cb3\cf11\b char \b0\cb1\cf0 infix\cb3\cf22 [\cb1\cf0 SIZE\cb3\cf22 ], \cb1\cf0 postfix\cb3\cf22 [\cb1\cf0 SIZE\cb3\cf22 ];
\par \cb1\cf0\ul0\i0\b0 150  
\par \cb1\cf0\ul0\i0\b0 151      \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "ASSUMPTION: The infix expression contains single letter variables and single digit constants only.\\n"\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 152      \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "\\nEnter Infix expression : "\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 153      \cb1\cf0 gets\cb3\cf22 (\cb1\cf0 infix\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 154  
\par \cb1\cf0\ul0\i0\b0 155      \cb1\cf0 InfixToPostfix\cb3\cf22 (\cb1\cf0 infix\cb3\cf22 , \cb1\cf0 postfix\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 156      \cb1\cf0 printf\cb3\cf22 (\cb3\cf17 "Postfix Expression: "\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 157      \cb1\cf0 puts\cb3\cf22 (\cb1\cf0 postfix\cb3\cf22 ); \cb3\cf4 /* print postfix expression */
\par \cb1\cf0\ul0\i0\b0 158      \cb1\cf0 system\cb3\cf22 (\cb3\cf17 "pause"\cb3\cf22 );
\par \cb1\cf0\ul0\i0\b0 159      \cb3\cf11\b return \b0\cb3\cf9 0\cb3\cf22 ;
\par \cb1\cf0\ul0\i0\b0 160  \cb3\cf22 \}
\par }